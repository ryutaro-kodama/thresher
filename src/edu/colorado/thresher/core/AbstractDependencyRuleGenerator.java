package edu.colorado.thresher.core;

import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import com.ibm.wala.analysis.pointers.HeapGraph;
import com.ibm.wala.classLoader.CallSiteReference;
import com.ibm.wala.classLoader.IClass;
import com.ibm.wala.classLoader.IField;
import com.ibm.wala.classLoader.IMethod;
import com.ibm.wala.ipa.callgraph.AnalysisCache;
import com.ibm.wala.ipa.callgraph.CGNode;
import com.ibm.wala.ipa.callgraph.CallGraph;
import com.ibm.wala.ipa.callgraph.propagation.ArrayContentsKey;
import com.ibm.wala.ipa.callgraph.propagation.ConcreteTypeKey;
import com.ibm.wala.ipa.callgraph.propagation.HeapModel;
import com.ibm.wala.ipa.callgraph.propagation.InstanceFieldKey;
import com.ibm.wala.ipa.callgraph.propagation.InstanceKey;
import com.ibm.wala.ipa.callgraph.propagation.PointerAnalysis;
import com.ibm.wala.ipa.callgraph.propagation.PointerKey;
import com.ibm.wala.ipa.callgraph.propagation.StaticFieldKey;
import com.ibm.wala.ipa.cha.ClassHierarchy;
import com.ibm.wala.ipa.cha.IClassHierarchy;
import com.ibm.wala.ssa.IR;
import com.ibm.wala.ssa.SSAArrayLoadInstruction;
import com.ibm.wala.ssa.SSAArrayStoreInstruction;
import com.ibm.wala.ssa.SSACFG;
import com.ibm.wala.ssa.SSACheckCastInstruction;
import com.ibm.wala.ssa.SSAGetInstruction;
import com.ibm.wala.ssa.SSAInstanceofInstruction;
import com.ibm.wala.ssa.SSAInstruction;
import com.ibm.wala.ssa.SSAInvokeInstruction;
import com.ibm.wala.ssa.SSALoadMetadataInstruction;
import com.ibm.wala.ssa.SSANewInstruction;
import com.ibm.wala.ssa.SSAPhiInstruction;
import com.ibm.wala.ssa.SSAPiInstruction;
import com.ibm.wala.ssa.SSAPutInstruction;
import com.ibm.wala.ssa.SSAReturnInstruction;
import com.ibm.wala.ssa.SSASwitchInstruction;
import com.ibm.wala.ssa.SymbolTable;
import com.ibm.wala.types.ClassLoaderReference;
import com.ibm.wala.types.FieldReference;
import com.ibm.wala.types.MethodReference;
import com.ibm.wala.types.TypeReference;
import com.ibm.wala.types.annotations.Annotation;
import com.ibm.wala.util.collections.HashMapFactory;
import com.ibm.wala.util.collections.HashSetFactory;
import com.ibm.wala.util.intset.OrdinalSet;
import com.ibm.wala.core.util.strings.Atom;

public class AbstractDependencyRuleGenerator {

  private boolean DEBUG;

  // map from globally unique line id to call graph nodes containing that line
  private final Map<Integer, Set<CGNode>> lineMethodMap;

  private final Map<IMethod, Integer> methodLineMap;

  // node -> rules transitively generated by that node (i.e. ALL rules generated
  // by node and callees)
  private final Map<CGNode, TreeSet<DependencyRule>> nodeAndCalleesRuleMap;

  // node -> rules generated locally by node mao
  private final Map<CGNode, TreeSet<DependencyRule>> nodeRuleMap;

  // map from instruction to globally unique line id for that instruction
  private final Map<SSAInstruction, Integer> instrLineMap;

  // TODO: this is a dumb idea...makes us lose context sensitivity
  // map from instruction to dependency rules associated with that instruction
  // private Map<SSAInstruction,Set<DependencyRule>> instrModMap;

  // map from (SSAInstruction * context) -> call graph
  private final Map<String, TreeSet<DependencyRule>> instrModMap;

  // a list of nodes that we have already generated dependency rules for so we
  // don't do redundant work
  private final Set<CGNode> alreadyGenerated;

  private final Map<Integer, DependencyRule> rules;
  public final HeapGraph hg;
  public final HeapModel hm;
  public final CallGraph cg;
  public final ClassHierarchy cha;
  public final PointerAnalysis pa;
  private final AnalysisCache cache;
  // counter to generate unique line number for each line in the program across
  // ALL files
  private int lineIdCounter;

  private final Map<CGNode, OrdinalSet<PointerKey>> modRef;
  private Map<PointerKey, Set<CGNode>> reversedModRef;

  // generate dependency rules for entire program
  public AbstractDependencyRuleGenerator(CallGraph cg, HeapGraph hg, HeapModel heapModel, 
                                         AnalysisCache cache, Map<CGNode, OrdinalSet<PointerKey>> modRef) {
    this.cg = cg;
    this.hg = hg;
    this.pa = hg.getPointerAnalysis();
    this.hm = heapModel;
    this.cha = (ClassHierarchy) cg.getClassHierarchy();
    this.lineIdCounter = 0;
    // list of all dependency rules
    this.rules = HashMapFactory.make();
    // map of (globally) unique line number to IR containing instruction at line number
    this.lineMethodMap = HashMapFactory.make();
    this.methodLineMap = HashMapFactory.make();
    this.instrLineMap = HashMapFactory.make();
    this.alreadyGenerated = HashSetFactory.make();
    this.nodeRuleMap = HashMapFactory.make();
    this.nodeAndCalleesRuleMap = HashMapFactory.make();
    this.instrModMap = HashMapFactory.make();
    this.modRef = modRef;
    this.cache = cache;
  }

  public void clearRules() {
    rules.clear();
  }

  static Set<DependencyRule> EMPTY = HashSetFactory.make();//new HashSet<DependencyRule>();

  public Set<DependencyRule> getRulesForNode(CGNode node) {
    this.generateRulesForNode(node);
    Set<DependencyRule> rules = nodeRuleMap.get(node);
    Set<DependencyRule> filtered = filterOutRefuted(rules);
    if (filtered != null)
      return filtered;
    return EMPTY;
  }

  /**
   * return a view of the rules for this CGNode that does not include rules
   * containing refuted edges
   * 
   * @param rules
   * @return
   */
  private Set<DependencyRule> filterOutRefuted(Set<DependencyRule> rules) {
    return rules;
  }

  public Set<DependencyRule> getRulesForNodeAndCallees(CGNode node) {
    Util.Unimp("don't call this.");
    Set<DependencyRule> rules = this.nodeAndCalleesRuleMap.get(node);
    if (rules == null) {
      Set<CGNode> explored = HashSetFactory.make();//new HashSet<CGNode>();
      rules = getRulesForNodeAndCallees(node, explored);
    } // else, rules already cached
    return filterOutRefuted(rules);
  }

  // helper
  private Set<DependencyRule> getRulesForNodeAndCallees(CGNode node, Set<CGNode> explored) {
    Util.Unimp("don't call this.");
    // generate rules and fill in map
    TreeSet<DependencyRule> rules = new TreeSet<DependencyRule>();
    explored.add(node);
    this.generateRulesForNode(node);
    Set<DependencyRule> rulesForNode = this.getRulesForNode(node);
    if (rulesForNode != null)
      rules.addAll(rulesForNode);
    // else Util.Debug("no rules for node " + node);
    Iterator<CallSiteReference> sites = node.iterateCallSites(); // get callees
    boolean possibleMutualRecursion = false;
    while (sites.hasNext()) {
      CallSiteReference site = sites.next();
      Set<CGNode> targets = cg.getPossibleTargets(node, site);
      for (CGNode target : targets) {
        // using the explored set here prevents infinite looping, but in the
        // case of mutual recurison, the rule sets for callee might not be
        // complete.
        // (i.e., we might skip addinr rules from a node in explored that we
        // should not skip). we fix this by not doing DP-style construction in
        // cases of possible mutual recursion
        if (!explored.contains(target)) {
          Set<DependencyRule> rulesForCallee = getRulesForNodeAndCallees(target, explored);
          if (rulesForCallee != null)
            rules.addAll(rulesForCallee);
        } else if (!target.equals(node)) { // if this is not a recursive call
          TreeSet<DependencyRule> rulesForCallee = this.nodeAndCalleesRuleMap.get(target);
          if (rulesForCallee != null)
            rules.addAll(rulesForCallee);
          else
            possibleMutualRecursion = true; // potential mutual recursion here.
                                            // can't add or keep searching for
                                            // rules
        } // else ordinary recursion, simply don't add rules (we already have
          // them in the set)
      }
    }
    if (!possibleMutualRecursion)
      this.nodeAndCalleesRuleMap.put(node, rules);
    return rules;
  }

  public void generateRules() {
    // not using built-in visitor because we need index of each SSAInstruction
    // to get line number information
    for (CGNode node : cg) {
      IMethod method = node.getMethod();
      Integer lineId = methodLineMap.get(method);
      if (lineId == null) {
        lineId = lineIdCounter++;
        methodLineMap.put(method, lineId);
      }

      if (alreadyGenerated.contains(node))
        continue;
      else
        alreadyGenerated.add(node);
      IR ir = node.getIR();
      if (DEBUG)
        System.out.println(ir);
      SSAInstruction[] insts = ir.getInstructions();
      // iterate over non-phi/non-pi instructions
      int i;
      for (i = 0; i < insts.length; i++) {
        SSAInstruction instr = insts[i];
        // int lineNum = Util.getSourceLineNumber(ir, i);
        // lineMethodMap.put(lineId, node);
        addToLineMethodMap(lineId, node);
        instrLineMap.put(instr, lineId);
        visit(instr, node, lineId, i, ir);
      }

      // handle phi instructions; hopefully lack of line numbers won't be an
      // issue?
      Iterator<SSAInstruction> instrIter = ir.iterateAllInstructions();
      while (instrIter.hasNext()) {
        SSAInstruction instr = instrIter.next();
        if (instr instanceof SSAPhiInstruction) {
          // lineMethodMap.put(lineId, node);
          addToLineMethodMap(lineId, node);
          instrLineMap.put(instr, lineId);
          visit(instr, node, lineId, i++, ir);
        } else if (instr instanceof SSAPiInstruction) {
          System.exit(1);
        }
      }
    }/*
      * for (DependencyRule rule : rules) { System.out.println(rule); }
      */
  }

  public boolean hasRelevantRule(CGNode initialCall, Set<DependencyRule> rules, Set<PointsToEdge> interestingEdges,
      Set<PointerVariable> interestingPathVars) {
    Util.Unimp("don't call this");
    /*
     * if (rules != null) { for (DependencyRule rule : rules) {
     * System.err.println("rulez " + rule); } }
     */
    if (rules != null && (interestingEdges.size() != 0 || interestingPathVars.size() != 0)) {
      Set<DependencyRule> filtered = filterOutRefuted(rules);
      for (DependencyRule rule : filtered) {
        PointsToEdge shown = rule.getShown();
        // System.err.println("SHOWN " + shown);
        PointerVariable lhs = shown.getSource();
        PointerVariable rhs = shown.getSink();
        // System.err.println("LHS " + lhs);
        for (PointsToEdge edge : interestingEdges) {
          if (lhs.isHeapVar() && lhs.equals(edge.getSource()) && shown.getField().equals(edge.getField())) {
            System.err.println("rule " + rule + " from " + initialCall + " is possibly relevant to pt-constraints");
            return true;
          }
        }
        if (lhs.isHeapVar() && interestingPathVars.contains(rhs)
            && !initialCall.getMethod().getName().toString().equals("getStringExtra")
            && !initialCall.getMethod().toString().contains("Ljava/lang")
            && !initialCall.getMethod().toString().contains("Landroid/view")
            && !initialCall.getMethod().toString().contains("Ljava/util/jar")
            && !initialCall.getMethod().toString().contains("Ljava/io")) {
          // !initialCall.getMethod().getName().toString().equals("inflate")) {
          // {
          // if (interestingPathVars.contains(lhs)) {
          System.err.println("rule " + rule + " is possibly relevant to path constraints");
          return true;
        }
      }
    }
    return false;
  }

  // returns true if a rule with a produced edge in interestingEdges occurs in a
  // generated rule
  public boolean generateRulesForNodeAndCheckRelevance(CGNode initialCall, CGNode node, Set<PointsToEdge> interestingEdges,
      Set<PointerVariable> interestingPathVars) {
    Util.Unimp("don't call this.");
    // if (DEBUG) System.out.println("GENERATING RULES FOR " + node);
    // System.err.println("GENERATING RULES FOR " + node);
    // TODO: USE CONTEXT INFORMATION!
    // if (VISUALIZE) Util.visualizeIR(cha, node.getIR(),
    // node.getIR().getMethod().getName().toString());
    IMethod method = node.getMethod();
    Integer lineId = methodLineMap.get(method);
    if (lineId == null) {
      lineId = lineIdCounter++;
      methodLineMap.put(method, lineId);
    }

    if (alreadyGenerated.contains(node)) {
      if (DEBUG)
        System.err.println("already generated rules for " + node);
      /*
       * if (nodeRuleMap.get(node) != null) { for (DependencyRule rule :
       * nodeRuleMap.get(node)) { System.err.println(rule); } }
       */
      return hasRelevantRule(initialCall, nodeRuleMap.get(node), interestingEdges, interestingPathVars);
    } else
      alreadyGenerated.add(node);
    // not using built-in visitor because we need index of each SSAInstruction
    // to get line number information
    IR ir = node.getIR();

    if (ir == null)
      return false;

    if (DEBUG)
      System.out.println(ir);

    SSAInstruction[] insts = ir.getInstructions();
    int i;
    for (i = 0; i < insts.length; i++) {
      SSAInstruction instr = insts[i];
      // int lineNum = Util.getSourceLineNumber(ir, i);
      // lineMethodMap.put(lineId, node);
      addToLineMethodMap(lineId, node);
      instrLineMap.put(instr, lineId);
      visit(instr, node, lineId, i, ir);
    }

    // handle phi instructions; hopefully lack of line numbers won't be an
    // issue?
    Iterator<SSAInstruction> instrIter = ir.iterateAllInstructions();
    while (instrIter.hasNext()) {
      SSAInstruction instr = instrIter.next();
      if (instr instanceof SSAPhiInstruction) {
        // System.out.println("PHI! " + instr);i
        // System.err.println("DOING PHI RULES!");
        // lineMethodMap.put(lineId, node);
        addToLineMethodMap(lineId, node);
        instrLineMap.put(instr, lineId);
        visit(instr, node, lineId, i++, ir);
        // if (visit(instr, node, lineId, i++, ir, interestingEdges)) return
        // true;
      }
    }
    // see if rule is relevant
    // Set<DependencyRule> rulesForNode = nodeRuleMap.get(node);

    return hasRelevantRule(initialCall, nodeRuleMap.get(node), interestingEdges, interestingPathVars);
  }

  // returns true if a rule with a produced edge in interestingEdges occurs in a
  // generated rule
  // public boolean generateRulesForNode(CGNode node, Set<PointsToEdge>
  // interestingEdges, Set<PointerVariable> interestingPathVars) {
  public void generateRulesForNode(CGNode node) {
    if (!alreadyGenerated.add(node))
      return;
    // Util.Debug("generateing rules for " + node);
    int i;
    int lineId = lineIdCounter++;
    IR ir = node.getIR();
    if (ir == null)
      return;

    // first, generate for instructions that we have line #'s for
    SSAInstruction[] insts = ir.getInstructions();
    for (i = 0; i < insts.length; i++) {
      SSAInstruction instr = insts[i];
      if (instr != null) {
        // addToLineMethodMap(lineId, node);
        // instrLineMap.put(instr, lineId);
        visit(instr, node, lineId, i, ir);
      }
    }

    // phi instr's aren't included in the instruction array; must generate their
    // rules separately
    Iterator phiIter = ir.iteratePhis();
    while (phiIter.hasNext()) {
      visit((SSAPhiInstruction) phiIter.next(), node, lineId, i++, ir);
    }
  }

  public Set<DependencyRule> generateAbstractRulesForInstr(SSAInstruction instr, CGNode node, int lineId, int lineNum, IR ir) {
    Set<DependencyRule> rules = new TreeSet<DependencyRule>();
    if (instr instanceof SSANewInstruction) {
      // Util.Unimp("dealing with NEW's!");
      SSANewInstruction instruction = (SSANewInstruction) instr;
      Util.Assert(instruction.hasDef(), "no def for new instr " + instr);
      InstanceKey site = null;
      // TODO: hack to get around bug in WALA--NPE in IR.getNewInstructionIndex(). Try PiecewiseOpcodeNoRefute to see t
      try {
        site = hm.getInstanceKeyForAllocation(node, instruction.getNewSite());
      } catch (NullPointerException e) { 
        Util.Print("caught WALA exception; moving on");
        return rules;
      }
      PointerKey local = hm.getPointerKeyForLocal(node, instruction.getDef());
      Util.Assert(local != null, "null local for " + local);
      if (site == null) {
        // find site by lookint at pts-to graph instead
        Iterator<Object> succs = hg.getSuccNodes(local);
        while (succs.hasNext()) {
          DependencyRule rule = Util.makeUnconditionalDependencyRule(instr, local, (InstanceKey) succs.next(),
              PointerStatement.EdgeType.Assign, lineId, lineNum, node);
          if (rule != null) rules.add(rule);
        }
      } else { // site not null
        // Util.Assert(site != null, "null site for " + instr + " in " + node);
        DependencyRule rule = Util.makeUnconditionalDependencyRule(instr, local, site, PointerStatement.EdgeType.Assign, lineId,
            lineNum, node);
        if (rule != null) rules.add(rule);
      }
    }

    else if (instr instanceof SSAPhiInstruction) {
      SSAPhiInstruction instruction = (SSAPhiInstruction) instr;
      PointerKey def = hm.getPointerKeyForLocal(node, instruction.getDef());
      if (def != null) {
        for (int i = 0; i < instruction.getNumberOfUses(); i++) {
          Util.Assert(instruction.getUse(i) != -1, "bad use! " + instruction + " " + i);
          PointerKey use = hm.getPointerKeyForLocal(node, instruction.getUse(i));
          if (use != null) {
            PointerVariable lhs = Util.makePointerVariable(def);
            PointerVariable rhsPointer = Util.makePointerVariable(use);
            PointerStatement stmt = new PointerStatement(instr, lhs, rhsPointer, PointerStatement.EdgeType.Assign, null, lineId,
                lineNum);
            Set<InstanceKey> possibleRHSs = HashSetFactory.make();//new HashSet<InstanceKey>();
            Iterator<Object> iter = hg.getSuccNodes(use);
            while (iter.hasNext()) {
              Object next = iter.next();
              Util.Assert(next instanceof InstanceKey, "expecting instanceKey, found " + next);
              possibleRHSs.add((InstanceKey) next);
            }
            if (possibleRHSs.isEmpty())
              continue;
            TreeSet<PointsToEdge> toShowSet = new TreeSet<PointsToEdge>();
            PointerVariable rhs = SymbolicPointerVariable.makeSymbolicVar(possibleRHSs);
            PointsToEdge shown = new PointsToEdge(lhs, rhs);
            PointsToEdge toShow = new PointsToEdge(rhsPointer, rhs);
            toShowSet.add(toShow);
            DependencyRule rule = new DependencyRule(shown, stmt, toShowSet, node, (SSACFG.BasicBlock) node.getIR()
                .getBasicBlockForInstruction(instr));
            rules.add(rule);
          }
        }
      }
    }

    else if (instr instanceof SSAReturnInstruction) {
      SSAReturnInstruction instruction = (SSAReturnInstruction) instr;
      if (instruction.returnsVoid()) return rules;
      SymbolTable tbl = ir.getSymbolTable();
      // if return value is null, we have no rules to generate
      if (tbl.isNullConstant(instruction.getResult())) return rules;
      PointerKey def = hm.getPointerKeyForLocal(node, instruction.getResult());
      PointerKey returnValue = hm.getPointerKeyForReturnValue(node);
      
      if (def != null && returnValue != null) {
        PointerVariable lhs = Util.makePointerVariable(def);
        PointerVariable rhsPointer = Util.makePointerVariable(returnValue);
        PointerStatement stmt = new PointerStatement(instr, lhs, rhsPointer, PointerStatement.EdgeType.Assign, null, lineId,
            lineNum);
        Set<InstanceKey> possibleRHSs = HashSetFactory.make();
        Iterator<Object> iter = hg.getSuccNodes(returnValue);
        while (iter.hasNext()) {
          Object next = iter.next();
          Util.Assert(next instanceof InstanceKey, "expecting instanceKey, found " + next);
          possibleRHSs.add((InstanceKey) next);
        }
        if (possibleRHSs.isEmpty()) return rules;
        TreeSet<PointsToEdge> toShowSet = new TreeSet<PointsToEdge>();
        PointerVariable rhs = SymbolicPointerVariable.makeSymbolicVar(possibleRHSs);
        PointsToEdge shown = new PointsToEdge(rhsPointer, rhs);
        PointsToEdge toShow = new PointsToEdge(lhs, rhs);
        toShowSet.add(toShow);
        DependencyRule rule = new DependencyRule(shown, stmt, toShowSet, node, (SSACFG.BasicBlock) node.getIR()
            .getBasicBlockForInstruction(instr));
        rules.add(rule);
      }
    }

    else if (instr instanceof SSAGetInstruction) {
      SSAGetInstruction instruction = (SSAGetInstruction) instr;
      FieldReference f = instruction.getDeclaredField();
      IField field = cg.getClassHierarchy().resolveField(f);
      if (field == null || f.getFieldType().isPrimitiveType())
        return rules;
      PointerKey def = hm.getPointerKeyForLocal(node, instruction.getDef());

      if (instruction.isStatic()) {
        PointerKey refKey = hm.getPointerKeyForStaticField(field);
        if (def != null && refKey != null) {
          // dispatch to regular assignment
          String fieldName = f.getDeclaringClass().toString() + "." + field.getName().toString();
          rules.addAll(generateAbstractRulesForAssign(instruction, def, refKey, node, fieldName, lineId, lineNum));
        } else {
          System.err
              .println("Problem finding lhs or rhs while generating dependency rules for static field SSAGetInstruction...exiting");
          System.exit(1);
        }
      } else {
        // y = x.f
        PointerKey refKey = hm.getPointerKeyForLocal(node, instruction.getRef());
        if (def != null && refKey != null) {
          PointerVariable lhs = Util.makePointerVariable(def);
          PointerVariable rhsPointerName = Util.makePointerVariable(refKey);
          String fieldName = f.getDeclaringClass().toString() + "." + f.getName().toString();
          PointerStatement stmt = Util.makePointerStatement(instr, lhs, rhsPointerName, PointerStatement.EdgeType.GetField,
              fieldName, lineId, lineNum);

          Set<InstanceKey> possibleXObjs = HashSetFactory.make();// new HashSet<InstanceKey>();
          Set<InstanceKey> possibleFVals = HashSetFactory.make();//new HashSet<InstanceKey>();
          Iterator<Object> iter = hg.getSuccNodes(refKey);
          while (iter.hasNext()) { // see what abstract loc's x could possible
                                   // point to
            Object next = iter.next();
            Util.Assert(next instanceof InstanceKey, "expecting instanceKey, found " + next);
            possibleXObjs.add((InstanceKey) next);
            Iterator<Object> iter2 = hg.getSuccNodes(next);
            while (iter2.hasNext()) { // iterate over possible f's
              InstanceFieldKey key = (InstanceFieldKey) iter2.next();
              if (!key.getField().equals(field))
                continue;
              Iterator<Object> iter3 = hg.getSuccNodes(key);
              while (iter3.hasNext()) { // iterate over possible values of f
                Object next3 = iter3.next();
                Util.Assert(next3 instanceof InstanceKey, "expecting instanceKey, found " + next3);
                possibleFVals.add((InstanceKey) next3);
              }
            }
          }
          if (possibleXObjs.isEmpty() || possibleFVals.isEmpty())
            return rules;
          PointerVariable xObj = SymbolicPointerVariable.makeSymbolicVar(possibleXObjs);
          PointerVariable yVal = SymbolicPointerVariable.makeSymbolicVar(possibleFVals);
          TreeSet<PointsToEdge> toShowSet = new TreeSet<PointsToEdge>();
          PointsToEdge shown = new PointsToEdge(lhs, yVal);
          PointsToEdge toShow0 = PointsToEdge.make(rhsPointerName, xObj, null), toShow1 = new PointsToEdge(xObj, yVal, field);
          toShowSet.add(toShow0);
          toShowSet.add(toShow1);
          DependencyRule rule = new DependencyRule(shown, stmt, toShowSet, node,
              (SSACFG.BasicBlock) ir.getBasicBlockForInstruction(instr));
          rules.add(rule);
        }
      }
    }

    else if (instr instanceof SSAPutInstruction) {
      SSAPutInstruction instruction = (SSAPutInstruction) instr;
      FieldReference f = instruction.getDeclaredField();
      IField field = cg.getClassHierarchy().resolveField(f);
      if (field == null || f.getFieldType().isPrimitiveType())
        return rules;

      PointerKey use = hm.getPointerKeyForLocal(node, instruction.getVal());

      if (instruction.isStatic()) {
        PointerKey fKey = hm.getPointerKeyForStaticField(field);
        if (use == null || fKey == null) {
          System.err
              .println("Problem finding lhs or rhs while generating dependency rules for static field SSAGetInstruction...exiting");
          System.exit(1);
        } else {
          // dispatch to regular assignment
          String fieldName = f.getDeclaringClass().toString() + "." + f.getName().toString();
          rules.addAll(generateAbstractRulesForAssign(instr, fKey, use, node, fieldName, lineId, lineNum));
        }
      } else {
        PointerKey fKey = hm.getPointerKeyForLocal(node, instruction.getRef());
        if (use == null || fKey == null) {
          System.err.println("Problem finding lhs or rhs while generating dependency rules for SSAGetInstruction...exiting");
          System.exit(1);
          // } else if (field.getFieldType().isPrimitiveType()) {
          // generateRulesForPrimitivePut(instr, fKey, use, node,
          // f.getName().toString(), lineId, lineNum);

        } else {
          // String fieldName = f.getDeclaringClass().toString() + "." +
          // f.getName().toString();
          rules.addAll(generateAbstractRulesForPutField(instr, fKey, use, node, field, lineId, lineNum));
        }
      }
    }

    else if (instr instanceof SSAArrayStoreInstruction) {
      SSAArrayStoreInstruction instruction = (SSAArrayStoreInstruction) instr;
      PointerKey arrayRef = hm.getPointerKeyForLocal(node, instruction.getArrayRef());
      PointerKey value = hm.getPointerKeyForLocal(node, instruction.getValue());
      rules.addAll(generateAbstractRulesForArrayStore(instruction, arrayRef, value, node, lineId, lineNum));
    }

    else if (instr instanceof SSAArrayLoadInstruction) {
      SSAArrayLoadInstruction instruction = (SSAArrayLoadInstruction) instr;

      PointerKey result = hm.getPointerKeyForLocal(node, instruction.getDef());
      PointerKey arrayRef = hm.getPointerKeyForLocal(node, instruction.getArrayRef());
      // Util.Debug("generating arrayLoad for " + instr);
      // System.out.println("Generating array load for " + result + " " +
      // arrayRef);
      if (result != null && arrayRef != null) {
        rules.addAll(generateAbstractRulesForArrayLoad(instruction, node, lineId, lineNum));
      }
    }
    
    /*
    else if (instr instanceof SSAInstanceofInstruction) {
      SSAInstanceofInstruction instanceCheck = (SSAInstanceofInstruction) instr;
      PointerKey lhsKey = hm.getPointerKeyForLocal(node, instanceCheck.getDef());
      PointerKey rhsKey = hm.getPointerKeyForLocal(node, instanceCheck.getRef());      
      PointerVariable lhs = Util.makePointerVariable(lhsKey);
      PointerVariable rhsPointer = Util.makePointerVariable(rhsKey);
      PointerStatement stmt = new PointerStatement(instr, lhs, rhsPointer, PointerStatement.EdgeType.Assign, null, lineId,
          lineNum);
      
      
      // generate dependency rule for each possible value of rhs
      // Iterator<Object> ptValues = hg.getSuccNodes(lhsKey);
      Iterator<Object> ptValues = hg.getSuccNodes(rhsKey);
      Set<InstanceKey> possibleKeys = HashSetFactory.make();// new HashSet<InstanceKey>();
      while (ptValues.hasNext()) {
        Object next = ptValues.next();
        Util.Assert(next instanceof InstanceKey, "found non-instance key " + next);
        possibleKeys.add((InstanceKey) next);
      }
      if (possibleKeys.isEmpty()) return rules;
      PointerVariable rhs = SymbolicPointerVariable.makeSymbolicVar(possibleKeys);
      PointsToEdge shown = new PointsToEdge(lhs, rhs, staticLhs);
      PointsToEdge toShow = new PointsToEdge(rhsPointer, rhs, staticRhs);
      TreeSet<PointsToEdge> toShowSet = new TreeSet<PointsToEdge>();
      toShowSet.add(toShow);
      DependencyRule rule = new DependencyRule(shown, stmt, toShowSet, node, (SSACFG.BasicBlock) node.getIR()
          .getBasicBlockForInstruction(instr));
      rules.add(rule
      
    }*/

    else if (instr instanceof SSAInvokeInstruction) {
      SSAInvokeInstruction instruction = (SSAInvokeInstruction) instr;
      rules.addAll(generateAbstractRulesForInvoke(instruction, node, lineId, lineNum)); 
    } else if (instr instanceof SSACheckCastInstruction) {
      SSACheckCastInstruction cci = (SSACheckCastInstruction) instr;
      PointerKey valKey = hm.getPointerKeyForLocal(node, cci.getVal());
      PointerKey resultKey = hm.getPointerKeyForLocal(node, cci.getResult());
      rules.addAll(generateAbstractRulesForAssign(instr, resultKey, valKey, node, null, lineId, lineNum));
    } 
    
    else if (instr instanceof SSALoadMetadataInstruction) {
      SSALoadMetadataInstruction load = (SSALoadMetadataInstruction) instr;
      if (Util.isClassMetadataGetter(load)) {
        // this instruction is lhs = something.class
        TypeReference ref = (TypeReference) load.getToken();
        IClass clazz = cha.lookupClass(ref);
        if (clazz == null) {
          // convert to application scope class and try again
          ref = TypeReference.findOrCreate(ClassLoaderReference.Application, ref.getName());
          clazz = cha.lookupClass(ref);
          Util.Assert(clazz != null);
        }

        PointerVariable typeVar = Util.makePointerVariable(new ConcreteTypeKey(clazz));
        PointerVariable lhs = new ConcretePointerVariable(node, instr.getDef(), this.hm);
        PointsToEdge edge = new PointsToEdge(lhs, typeVar);
        PointerStatement stmt = Util.makePointerStatement(instr, lhs, typeVar, PointerStatement.EdgeType.Assign,
            null, lineId, lineNum);
        rules.add(new DependencyRule(edge, stmt, new TreeSet<PointsToEdge>(), node, 
            (SSACFG.BasicBlock) ir.getBasicBlockForInstruction(instr)));
      }
    }
    /*
     * else if (instr instanceof SSABinaryOpInstruction || instr instanceof
     * SSAGotoInstruction || instr instanceof SSAArrayLengthInstruction || instr
     * instanceof SSAMonitorInstruction || instr instanceof
     * SSALoadMetadataInstruction || instr instanceof SSAComparisonInstruction
     * || instr instanceof SSAGetCaughtExceptionInstruction || instr instanceof
     * SSAThrowInstruction || instr instanceof SSAConversionInstruction || instr
     * instanceof SSAInstanceofInstruction) { } // do nothing
     */
    else {
      
      if (instr instanceof SSASwitchInstruction) {
        /*
        //Util.Print(ir);
        SymbolTable tbl = ir.getSymbolTable();
        SSASwitchInstruction switch_ = (SSASwitchInstruction) instr;
        int[] casesAndLabels = switch_.getCasesAndLabels();
        for (int i = 0; i < casesAndLabels.length; i += 2) {
          //Util.Print("target " + switch_.getTarget(casesAndLabels[i]));
          //Util.Print("const: " + tbl.getConstant(casesAndLabels[i]));
        }
        */
      }
      if (Options.DEBUG) Util.Debug("instr " + instr + " does not manipulate the heap.");
      // Util.Unimp("UNHANDLED INSTR " + instr);
    }

    return rules;

  }
  
  private Set<DependencyRule> generateAbstractRulesForInvoke(SSAInvokeInstruction instruction, CGNode node, 
                                                            int lineId, int lineNum) {
    MethodReference method = instruction.getCallSite().getDeclaredTarget();
    // no rules to generate for fakeWorldClinit
    if (method.equals(WALACFGUtil.getFakeWorldClinitNode(cg).getMethod().getReference())) return Collections.EMPTY_SET;
    Set<CGNode> callees = cg.getPossibleTargets(node, instruction.getCallSite());
    return generateAbstractRulesForInvoke(instruction, node, callees, lineId, lineNum);
  }
  
  public Set<DependencyRule> generateAbstractRulesForInvoke(SSAInvokeInstruction instr, CGNode node, CGNode callee) {
    return generateAbstractRulesForInvoke(instr, node, Collections.singleton(callee), 0, 1);
  }
  
  private Set<DependencyRule> generateAbstractRulesForInvoke(SSAInvokeInstruction instr, CGNode node, Set<CGNode> callees, 
                                                            int lineId, int lineNum) {
    Set<DependencyRule> rules = HashSetFactory.make();

    IR ir = node.getIR();
    // TODO: we could be even more abstract here and merge calls...but
    // currently, we only support a SymbolicPointerVariable being a
    // disjunction of InstanceKeys. to merge calls into a single rule, we also need
    // a disjunction of PointerKeys on the left
    for (CGNode callee : callees) {
      if (instr.hasDef()) {
        // generate return value rule
        PointerVariable lhs = new ConcretePointerVariable(node, instr.getDef(), hm);
        PointerVariable retval = Util.makeReturnValuePointer(callee, hm);
        if (retval == null) continue;
        PointerStatement stmt = Util.makePointerStatement(instr, lhs, retval, PointerStatement.EdgeType.Assign, null, lineId,
            lineNum);
        Iterator<Object> retvalSuccs = hg.getSuccNodes(retval.getInstanceKey());
        Set<InstanceKey> possibleRetvals = HashSetFactory.make();
        while (retvalSuccs.hasNext()) {
          possibleRetvals.add((InstanceKey) retvalSuccs.next());
        }
        if (!possibleRetvals.isEmpty()) {
          PointerVariable succ = SymbolicPointerVariable.makeSymbolicVar(possibleRetvals);
          PointsToEdge shown = new PointsToEdge(lhs, succ);
          TreeSet<PointsToEdge> toShow = new TreeSet<PointsToEdge>();
          PointsToEdge toShowEdge = new PointsToEdge(retval, succ);
          if (!toShowEdge.containsStringConst()) toShow.add(toShowEdge);
          DependencyRule rule = new DependencyRule(shown, stmt, toShow, node,
              (SSACFG.BasicBlock) ir.getBasicBlockForInstruction(instr));
          rules.add(rule);
        }
      }
      
      SymbolTable tbl = ir.getSymbolTable();
      // if the call is siteName(arg0, ..., argn), for the ith parameter, assign siteName-vi := argi
      for (int j = 0; j < instr.getNumberOfUses(); j++) {
        int localValNum = instr.getUse(j);
        if (tbl.isNullConstant(localValNum)) continue; 
        PointerVariable lhs = new ConcretePointerVariable(hm.getPointerKeyForLocal(callee, j + 1), callee, j + 1);
        PointerKey rhsKey = hm.getPointerKeyForLocal(node, localValNum);
        PointerVariable rhsPointer = Util.makePointerVariable(rhsKey);
        PointerStatement stmt = Util.makePointerStatement(instr, lhs, rhsPointer, PointerStatement.EdgeType.Assign, null, lineId,
            lineNum);
        
        Set<InstanceKey> possibleParamVals = HashSetFactory.make();

        // consider possible values for rhs
        Iterator<Object> ptValues = hg.getSuccNodes(rhsKey);
        while (ptValues.hasNext()) {
          InstanceKey next = (InstanceKey) ptValues.next();
          // don't track exception types
          if (!Util.isExceptionType(next, cha)) {
            possibleParamVals.add(next);
          }
        }
        if (possibleParamVals.isEmpty()) continue;
        TreeSet<PointsToEdge> toShowSet = new TreeSet<PointsToEdge>();
        PointerVariable paramVal = SymbolicPointerVariable.makeSymbolicVar(possibleParamVals);

        PointsToEdge shown = new PointsToEdge(lhs, paramVal);
        PointsToEdge toShowEdge = new PointsToEdge(rhsPointer, paramVal);
        if (!toShowEdge.containsStringConst()) toShowSet.add(toShowEdge);
        DependencyRule rule = new DependencyRule(shown, stmt, toShowSet, node,
            (SSACFG.BasicBlock) ir.getBasicBlockForInstruction(instr));
        rules.add(rule);
      }
    }
    return rules;
  }
  

  // the "visitor"
  public Set<DependencyRule> visit(SSAInstruction instr, CGNode node, int lineId, int lineNum, IR ir) {
    Set<DependencyRule> rules = new TreeSet<DependencyRule>();
    // get the line number for the instruction;
    // ISSABasicBlock blk = ir.getBasicBlockForInstruction(instr);
    // int firstLine = blk.getFirstInstructionIndex();
    // System.err.println("instr " + instr + " first line " + firstLine);
    // System.exit(1);

    // System.err.println("INSTR IS " + instr);
    if (instr instanceof SSANewInstruction) {
      SSANewInstruction instruction = (SSANewInstruction) instr;
      InstanceKey site = hm.getInstanceKeyForAllocation(node, instruction.getNewSite());
      PointerKey local = hm.getPointerKeyForLocal(node, instruction.getDef());

      if (site != null && local != null) {
        DependencyRule rule = Util.makeUnconditionalDependencyRule(instr, local, site, PointerStatement.EdgeType.Assign, lineId,
            lineNum, node);
        if (rule != null) {
          addRule(rule, instr, node);
          rules.add(rule);
        }
      } else {
        if (DEBUG) {
          // System.err.println("Problem finding lhs or rhs while generating dependency rules for SSANewInstruction...exiting");
          // System.err.println("instr " + instruction);
          // System.err.println("site " + site);
          // System.err.println("local " + local);
        }
        // Util.Assert(false,
        // "Problem finding lhs or rhs while generating dependency rules for SSANewInstruction...exiting");
      }
    }

    else if (instr instanceof SSAPiInstruction) {
      Util.Assert(false, "UNTESTED!");
      SSAPiInstruction instruction = (SSAPiInstruction) instr;
      PointerKey def = hm.getPointerKeyForLocal(node, instruction.getDef());
      PointerKey use = hm.getPointerKeyForLocal(node, instruction.getVal());
      if (def != null && use != null) {
        rules.addAll(generateRulesForAssign(instr, def, use, node, null, lineId, lineNum));
      }
    }

    else if (instr instanceof SSAPhiInstruction) {
      SSAPhiInstruction instruction = (SSAPhiInstruction) instr;
      PointerKey def = hm.getPointerKeyForLocal(node, instruction.getDef());
      if (def != null) {
        for (int i = 0; i < instruction.getNumberOfUses(); i++) {
          PointerKey use = null;
          if (instruction.getUse(i) != -1)
            use = hm.getPointerKeyForLocal(node, instruction.getUse(i));
          if (use != null)
            rules.addAll(generateRulesForPhi(instr, def, use, node, null, lineId, lineNum));
        }
      }
    }

    else if (instr instanceof SSAReturnInstruction) {
      SSAReturnInstruction instruction = (SSAReturnInstruction) instr;
      // skip returns of primitive type (optimization)
      // if (instruction.returnsPrimitiveType() || instruction.returnsVoid()) {
      if (instruction.returnsVoid()) return rules;
      SymbolTable tbl = ir.getSymbolTable();
      // if return value is null, we have no rules to generate
      if (tbl.isNullConstant(instruction.getResult())) return rules;
      
      PointerKey def = hm.getPointerKeyForLocal(node, instruction.getResult());
      PointerKey returnValue = hm.getPointerKeyForReturnValue(node);
      if (def != null && returnValue != null) {
        rules.addAll(generateRulesForReturn(instr, def, returnValue, node, null, lineId, lineNum));
      }
    }

    else if (instr instanceof SSAArrayLoadInstruction) {
      SSAArrayLoadInstruction instruction = (SSAArrayLoadInstruction) instr;

      // skip arrays of primitive type
      // if (instruction.typeIsPrimitive()) {
      // return;
      // }

      PointerKey result = hm.getPointerKeyForLocal(node, instruction.getDef());
      PointerKey arrayRef = hm.getPointerKeyForLocal(node, instruction.getArrayRef());
      // Util.Debug("generating arrayLoad for " + instr);
      // System.out.println("Generating array load for " + result + " " +
      // arrayRef);
      if (result != null && arrayRef != null) {
        rules.addAll(generateRulesForArrayLoad(instruction, node, lineId, lineNum));
        // generateRulesForGetField(instr, result, arrayRef, node,
        // PointerStatement.ARRAY, lineId, lineNum);
      }
    }

    else if (instr instanceof SSAArrayStoreInstruction) {
      SSAArrayStoreInstruction instruction = (SSAArrayStoreInstruction) instr;
      // skip arrays of primitive type (optimization)
      // if (instruction.typeIsPrimitive()) {
      // return;
      // }
      // make node for used value
      PointerKey value = hm.getPointerKeyForLocal(node, instruction.getValue());
      PointerKey arrayRef = hm.getPointerKeyForLocal(node, instruction.getArrayRef());

      rules.addAll(generateRulesForArrayStore(instr, arrayRef, value, node, lineId, lineNum));
    }

    else if (instr instanceof SSAInvokeInstruction) {
      SSAInvokeInstruction instruction = (SSAInvokeInstruction) instr;
      MethodReference method = instruction.getCallSite().getDeclaredTarget();
      if (method.equals(WALACFGUtil.getFakeWorldClinitNode(cg).getMethod().getReference()))
        return rules; // no rules to generate for this invoke
      Set<CGNode> callees = cg.getPossibleTargets(node, instruction.getCallSite());
      for (CGNode callee : callees) {
        // Util.Debug("generating call rules for " + callee);
        if (instr.hasDef()) {
          // generate return value rule
          PointerVariable lhs = new ConcretePointerVariable(node, instr.getDef(), hm);
          PointerVariable retval = Util.makeReturnValuePointer(callee, hm);
          PointerStatement stmt = Util.makePointerStatement(instr, lhs, retval, PointerStatement.EdgeType.Assign, null, lineId,
              lineNum);
          Iterator<Object> retvalSuccs = hg.getSuccNodes(retval.getInstanceKey());
          while (retvalSuccs.hasNext()) {
            PointerVariable succ = Util.makePointerVariable(retvalSuccs.next());
            if (succ == null) continue; // makePointerVariable() can return null for exception literals
            PointsToEdge shown = new PointsToEdge(lhs, succ);
            TreeSet<PointsToEdge> toShow = new TreeSet<PointsToEdge>();
            toShow.add(new PointsToEdge(retval, succ));
            DependencyRule rule = new DependencyRule(shown, stmt, toShow, node,
                (SSACFG.BasicBlock) ir.getBasicBlockForInstruction(instr));
            addRule(rule, instr, node);
            rules.add(rule);
          }
        }

        SymbolTable tbl = ir.getSymbolTable();
        // if the call is siteName(arg0, ..., argn), for the ith parameter,
        // assign siteName-vi := argi
        for (int j = 0; j < instruction.getNumberOfUses(); j++) {
          int localValNum = instruction.getUse(j);
          if (tbl.isNullConstant(localValNum)) continue;
          PointerVariable lhs = new ConcretePointerVariable(hm.getPointerKeyForLocal(callee, j + 1), callee, j + 1);
          PointerKey rhsKey = hm.getPointerKeyForLocal(node, localValNum);
          PointerVariable rhsPointer = Util.makePointerVariable(rhsKey);
          if (rhsPointer == null) continue;
          PointerStatement stmt = Util.makePointerStatement(instr, lhs, rhsPointer, PointerStatement.EdgeType.Assign, null, lineId,
              lineNum);
          Iterator<Object> ptValues = hg.getSuccNodes(rhsKey);

          while (ptValues.hasNext()) {
            PointerVariable rhs = Util.makePointerVariable(ptValues.next());
            if (rhs == null) continue;
            if (rhs != null) {
              PointsToEdge shown = new PointsToEdge(lhs, rhs);
              PointsToEdge toShow = new PointsToEdge(rhsPointer, rhs);
              TreeSet<PointsToEdge> toShowSet = new TreeSet<PointsToEdge>();
              if (!toShow.containsStringConst())
                toShowSet.add(toShow);
              DependencyRule rule = new DependencyRule(shown, stmt, toShowSet, node,
                  (SSACFG.BasicBlock) ir.getBasicBlockForInstruction(instr));
              addRule(rule, instr, node);
              rules.add(rule);
            } 
          }
        }
      }
    }

    else if (instr instanceof SSAGetInstruction) {
      // System.err.println("FOR INSTR " + instr);
      SSAGetInstruction instruction = (SSAGetInstruction) instr;
      FieldReference field = instruction.getDeclaredField();
      // skip getfields of primitive type (optimization)
      //boolean primitive = field.getFieldType().isPrimitiveType();
      // if (field.getFieldType().isPrimitiveType()) return;

      IField f = cg.getClassHierarchy().resolveField(field);
      if (f == null) {
        if (DEBUG)
          System.err.println("Error resolving field");
        return rules;
      }

      PointerKey def = hm.getPointerKeyForLocal(node, instruction.getDef());

      if (instruction.isStatic()) {
        PointerKey refKey = hm.getPointerKeyForStaticField(f);
        if (def != null && refKey != null) {
          // dispatch to regular assignment
          String fieldName = f.getDeclaringClass().toString() + "." + f.getName().toString();
          rules.addAll(generateRulesForAssign(instr, def, refKey, node, fieldName, lineId, lineNum));
        } else {
          System.err
              .println("Problem finding lhs or rhs while generating dependency rules for static field SSAGetInstruction...exiting");
          System.exit(1);
        }
      } else {
        PointerKey refKey = hm.getPointerKeyForLocal(node, instruction.getRef());
        if (def != null && refKey != null) {
          // this is a tricky case. refKey is a local var that points to a
          // reference pointing to a reference through a field = 3 levels of
          // dereference
          PointerVariable lhs = Util.makePointerVariable(def);
          PointerVariable rhsPointerName = Util.makePointerVariable(refKey);
          String fieldName = f.getDeclaringClass().toString() + "." + f.getName().toString();
          // PointerStatement stmt = Util.makePointerStatement(lhs,
          // rhsPointerName, PointerStatement.EdgeType.GetField,
          // f.getName().toString(), lineId, lineNum);
          PointerStatement stmt = Util.makePointerStatement(instr, lhs, rhsPointerName, PointerStatement.EdgeType.GetField,
              fieldName, lineId, lineNum);

          // deref level 1 : what reference ref0 does the local var point to?
          Iterator<Object> ref0Values = hg.getSuccNodes(refKey);
          while (ref0Values.hasNext()) {
            Object ref0 = ref0Values.next();
            PointerVariable rhsPointer = Util.makePointerVariable(ref0);
            // deref level 2 : what reference ref1 does ref0 point to through
            // its field?

            Iterator<Object> ref1Values = hg.getSuccNodes(ref0);
            while (ref1Values.hasNext()) {
              Object ref1 = ref1Values.next();
              Util.Assert(ref1 instanceof InstanceFieldKey, "What's going on here? " + ref1 + " not an instance field key");
              InstanceFieldKey ifk = (InstanceFieldKey) ref1;
              // if (DEBUG) System.out.println("does " + f + " eq " +
              // ifk.getField() + "? " + f.equals(ifk.getField()));
              // if (f == ifk.getField()) {
              if (f.equals(ifk.getField())) {
                // deref level 3 : what reference ref2 does the ref1 point to?
                Iterator<Object> ref2Values = hg.getSuccNodes(ref1);
                // Util.Assert(ref2Values.hasNext(), ref1 +
                // " has no successors! huh?");

                if (!ref2Values.hasNext()) {
                  // Util.Assert(false, ref1 + " has no successors! huh?");
                  // if (DEBUG) System.out.println(ref1 +
                  // " has no successors! huh?");
                  // handleProblemWithPointsToGraphCase(instr, node, f, lineId,
                  // lineNum);
                  // return;
                  // continue;
                }

                while (ref2Values.hasNext()) {
                  InstanceKey rhsObj = (InstanceKey) ref2Values.next();

                  // if (seenRHSes.contains(rhsObj)) continue;
                  // else seenRHSes.add(rhsObj);
                  // generate dependency rule
                  PointerVariable rhs = Util.makePointerVariable(rhsObj);
                  if (rhs != null) {
                    PointsToEdge shown = new PointsToEdge(lhs, rhs);
                    PointsToEdge toShow0 = PointsToEdge.make(rhsPointerName, rhsPointer, null);
                    PointsToEdge toShow1 = PointsToEdge.make(rhsPointer, rhs, ifk);

                    TreeSet<PointsToEdge> toShowSet = new TreeSet<PointsToEdge>();
                    if (toShow0 != null && !toShow0.containsStringConst())
                      toShowSet.add(toShow0);
                    if (toShow1 != null && !toShow1.containsStringConst())
                      toShowSet.add(toShow1);
                    DependencyRule rule = new DependencyRule(shown, stmt, toShowSet, node,
                        (SSACFG.BasicBlock) ir.getBasicBlockForInstruction(instr));
                    addRule(rule, instr, node);
                    rules.add(rule);
                  }
                }
              }
            }
          }
        } else {
          System.err
              .println("Problem finding lhs or rhs while generating dependency rules for regular field SSAGetInstruction...exiting");
          System.exit(1);
        }
      }
    }

    else if (instr instanceof SSAPutInstruction) {
      SSAPutInstruction instruction = (SSAPutInstruction) instr;
      FieldReference field = instruction.getDeclaredField();

      // skip getfields of primitive type (optimization)
      // if (field.getFieldType().isPrimitiveType()) return;
      // if (field.getFieldType().isPrimitiveType())
      // generateRulesForPrimitiveTypePut(instruction);

      IField f = cg.getClassHierarchy().resolveField(field);
      if (f == null) {
        // System.err.println("Error resolving field");
        return rules;
      }

      PointerKey use = hm.getPointerKeyForLocal(node, instruction.getVal());

      if (instruction.isStatic()) {
        PointerKey fKey = hm.getPointerKeyForStaticField(f);
        if (use == null || fKey == null) {
          System.err
              .println("Problem finding lhs or rhs while generating dependency rules for static field SSAGetInstruction...exiting");
          System.exit(1);
          // } else if (field.getFieldType().isPrimitiveType()) {
          // generateRulesForPrimitiveTypePut(instruction);

        } else {
          // dispatch to regular assignment
          String fieldName = f.getDeclaringClass().toString() + "." + f.getName().toString();
          rules.addAll(generateRulesForAssign(instr, fKey, use, node, fieldName, lineId, lineNum));
        }
      } else {
        PointerKey fKey = hm.getPointerKeyForLocal(node, instruction.getRef());
        if (use == null || fKey == null) {
          System.err.println("Problem finding lhs or rhs while generating dependency rules for SSAGetInstruction...exiting");
          System.exit(1);
        } else {
          // String fieldName = f.getDeclaringClass().toString() + "." +
          // f.getName().toString();
          rules.addAll(generateRulesForPutField(instr, fKey, use, node, f, lineId, lineNum));
        }
      }

      /*
       * if (instruction.isStatic()) { PointerKey fKey =
       * heapModel.getPointerKeyForStaticField(f); if (use != null && fKey !=
       * null) { // dispatch to regular assignment generateRulesForAssign(instr,
       * fKey, use, node, f.getName().toString(), lineId, lineNum); } else {
       * System.err.println(
       * "Problem finding lhs or rhs while generating dependency rules for static field SSAGetInstruction...exiting"
       * ); System.exit(1); } } else { PointerKey fKey =
       * heapModel.getPointerKeyForLocal(node, instruction.getRef()); if (use !=
       * null && fKey != null) { generateRulesForPutField(instr, fKey, use,
       * node, f.getName().toString(), lineId, lineNum); } else {
       * System.err.println(
       * "Problem finding lhs or rhs while generating dependency rules for SSAGetInstruction...exiting"
       * ); System.exit(1); } }
       */
    } else if (instr instanceof SSACheckCastInstruction) {
      SSACheckCastInstruction cci = (SSACheckCastInstruction) instr;
      PointerKey valKey = hm.getPointerKeyForLocal(node, cci.getVal());
      PointerKey resultKey = hm.getPointerKeyForLocal(node, cci.getResult());
      rules.addAll(generateRulesForAssign(instr, resultKey, valKey, node, null, lineId, lineNum));
      // generateRulesForAssign(instr, valKey, resultKey, node, null, lineId,
      // lineNum);
      // System.exit(1);
    } else if (instr != null) {
      // Util.Assert(false, "UNDHANDLED INSTRUCTION TYPE " + instr);
    }
    return rules;
  }

  private Set<DependencyRule> generateRulesForReturn(SSAInstruction instr, PointerKey lhsKey, PointerKey rhsKey, CGNode node,
      String fieldName, int lineId, int lineNum) {
    TreeSet<DependencyRule> rules = new TreeSet<DependencyRule>();
    PointerVariable lhs = Util.makePointerVariable(lhsKey);
    PointerVariable rhsPointer = Util.makePointerVariable(rhsKey);
    PointerStatement stmt = new PointerStatement(instr, lhs, rhsPointer, PointerStatement.EdgeType.Assign, fieldName, lineId,
        lineNum);
    
    // generate dependency rule for each possible value of rhs
    Iterator<Object> ptValues = hg.getSuccNodes(lhsKey);
    while (ptValues.hasNext()) {
      PointerVariable rhs = Util.makePointerVariable(ptValues.next());
      if (rhs != null) {
        PointsToEdge shown = new PointsToEdge(rhsPointer, rhs);
        PointsToEdge toShow = new PointsToEdge(lhs, rhs);
        TreeSet<PointsToEdge> toShowSet = new TreeSet<PointsToEdge>();
        if (!toShow.containsStringConst())
          toShowSet.add(toShow);
        DependencyRule rule = new DependencyRule(shown, stmt, toShowSet, node, (SSACFG.BasicBlock) node.getIR()
            .getBasicBlockForInstruction(instr));
        addRule(rule, instr, node);
        rules.add(rule);
      }
    }
    return rules;
  }

  private Set<DependencyRule> generateRulesForAssign(SSAInstruction instr, PointerKey lhsKey, PointerKey rhsKey, CGNode node,
      String fieldName, int lineId, int lineNum) {
    TreeSet<DependencyRule> rules = new TreeSet<DependencyRule>();
    PointerVariable lhs = Util.makePointerVariable(lhsKey);
    PointerVariable rhsPointer = Util.makePointerVariable(rhsKey);
    PointerStatement stmt = new PointerStatement(instr, lhs, rhsPointer, PointerStatement.EdgeType.Assign, fieldName, lineId,
        lineNum);

    PointerKey staticLhs = null, staticRhs = null;
    if (lhsKey instanceof StaticFieldKey)
      staticLhs = lhsKey;
    if (rhsKey instanceof StaticFieldKey)
      staticRhs = rhsKey;
    // generate dependency rule for each possible value of rhs
    // Iterator<Object> ptValues = hg.getSuccNodes(lhsKey);
    Iterator<Object> ptValues = hg.getSuccNodes(rhsKey);
    while (ptValues.hasNext()) {
      PointerVariable rhs = Util.makePointerVariable(ptValues.next());
      if (rhs != null) {
        PointsToEdge shown = new PointsToEdge(lhs, rhs, staticLhs);
        PointsToEdge toShow = new PointsToEdge(rhsPointer, rhs, staticRhs);
        TreeSet<PointsToEdge> toShowSet = new TreeSet<PointsToEdge>();
        if (!toShow.containsStringConst())
          toShowSet.add(toShow);
        DependencyRule rule = new DependencyRule(shown, stmt, toShowSet, node, (SSACFG.BasicBlock) node.getIR()
            .getBasicBlockForInstruction(instr));
        addRule(rule, instr, node);
        rules.add(rule);
      }
    }
    return rules;
  }

  private Set<DependencyRule> generateAbstractRulesForAssign(SSAInstruction instr, PointerKey lhsKey, PointerKey rhsKey,
      CGNode node, String fieldName, int lineId, int lineNum) {
    TreeSet<DependencyRule> rules = new TreeSet<DependencyRule>();
    PointerVariable lhs = Util.makePointerVariable(lhsKey);
    PointerVariable rhsPointer = Util.makePointerVariable(rhsKey);
    PointerStatement stmt = new PointerStatement(instr, lhs, rhsPointer, PointerStatement.EdgeType.Assign, fieldName, lineId,
        lineNum);

    PointerKey staticLhs = null, staticRhs = null;
    if (lhsKey instanceof StaticFieldKey)
      staticLhs = lhsKey;
    if (rhsKey instanceof StaticFieldKey)
      staticRhs = rhsKey;
    // generate dependency rule for each possible value of rhs
    // Iterator<Object> ptValues = hg.getSuccNodes(lhsKey);
    Iterator<Object> ptValues = hg.getSuccNodes(rhsKey);
    Set<InstanceKey> possibleKeys = HashSetFactory.make();// new HashSet<InstanceKey>();
    while (ptValues.hasNext()) {
      Object next = ptValues.next();
      Util.Assert(next instanceof InstanceKey, "found non-instance key " + next);
      possibleKeys.add((InstanceKey) next);
    }
    if (possibleKeys.isEmpty()) return rules;
    PointerVariable rhs = SymbolicPointerVariable.makeSymbolicVar(possibleKeys);
    PointsToEdge shown = new PointsToEdge(lhs, rhs, staticLhs);
    PointsToEdge toShow = new PointsToEdge(rhsPointer, rhs, staticRhs);
    TreeSet<PointsToEdge> toShowSet = new TreeSet<PointsToEdge>();
    toShowSet.add(toShow);
    DependencyRule rule = new DependencyRule(shown, stmt, toShowSet, node, (SSACFG.BasicBlock) node.getIR()
        .getBasicBlockForInstruction(instr));
    rules.add(rule);
    return rules;
  }

  private Set<DependencyRule> generateRulesForPhi(SSAInstruction instr, PointerKey lhsKey, PointerKey rhsKey, CGNode node,
      String fieldName, int lineId, int lineNum) {
    TreeSet<DependencyRule> rules = new TreeSet<DependencyRule>();
    PointerVariable lhs = Util.makePointerVariable(lhsKey);
    PointerVariable rhsPointer = Util.makePointerVariable(rhsKey);
    PointerStatement stmt = new PointerStatement(instr, lhs, rhsPointer, PointerStatement.EdgeType.Assign, fieldName, lineId,
        lineNum);

    // generate dependency rule for each possible value of rhs
    Iterator<Object> ptValues = hg.getSuccNodes(rhsKey);
    while (ptValues.hasNext()) {
      PointerVariable rhs = Util.makePointerVariable(ptValues.next());
      if (rhs != null) {
        PointsToEdge shown = new PointsToEdge(lhs, rhs);
        PointsToEdge toShow = new PointsToEdge(rhsPointer, rhs);
        TreeSet<PointsToEdge> toShowSet = new TreeSet<PointsToEdge>();
        if (!toShow.containsStringConst())
          toShowSet.add(toShow);
        DependencyRule rule = new DependencyRule(shown, stmt, toShowSet, node, (SSACFG.BasicBlock) node.getIR()
            .getBasicBlockForInstruction(instr));
        if (rule.getShown() != null) {
          addRule(rule, instr, node);
          rules.add(rule);
        }
      }
      // System.out.println("PHI RULE " + rule);
    }
    return rules;
  }

  // x.f = y
  private Set<DependencyRule> generateRulesForPutField(SSAInstruction instr, PointerKey lhsKey, PointerKey rhsKey, CGNode node,
      IField field, int lineId, int lineNum) {
    // Util.Debug("putfield instr " + instr);

    boolean selfAssignment = false;
    if (instr.getUse(0) == instr.getUse(1))
      selfAssignment = true; // special case: x.f = x

    TreeSet<DependencyRule> rules = new TreeSet<DependencyRule>();
    PointerVariable lhs = Util.makePointerVariable(lhsKey);
    PointerVariable rhsPointer = Util.makePointerVariable(rhsKey);
    PointerStatement stmt = Util.makePointerStatement(instr, lhs, rhsPointer, PointerStatement.EdgeType.PutField, field.toString(),
        lineId, lineNum);

    // consider possible values for x
    Iterator<Object> fieldValues = hg.getSuccNodes(lhsKey);
    while (fieldValues.hasNext()) {
      InstanceKey fieldKey = (InstanceKey) fieldValues.next();
      // Util.Debug("field value " + fieldKey);
      PointerVariable fieldPointer = Util.makePointerVariable(fieldKey);
      if (fieldPointer != null) {
        PointsToEdge toShow0 = PointsToEdge.make(lhs, fieldPointer, null);
        // consider possible values for y
        Iterator<Object> ptValues = hg.getSuccNodes(rhsKey);
        if (!ptValues.hasNext()) {
          // rhs is a constant
          PointerVariable rhs = new ConcretePointerVariable("CONST");
          PointsToEdge shown = new PointsToEdge(fieldPointer, rhs, new InstanceFieldKey(fieldKey, field));
          DependencyRule rule = new DependencyRule(shown, stmt, new TreeSet<PointsToEdge>(), node, (SSACFG.BasicBlock) node.getIR()
              .getBasicBlockForInstruction(instr));
          // Util.Debug("adding const rule " + rule);
          addRule(rule, instr, node);
          rules.add(rule);
        }
        while (ptValues.hasNext()) {
          TreeSet<PointsToEdge> toShowSet = new TreeSet<PointsToEdge>();
          if (toShow0 != null && !toShow0.containsStringConst())
            toShowSet.add(toShow0);
          PointerVariable rhs = Util.makePointerVariable(ptValues.next());
          // Util.Debug("rhs " + rhs);
          if (rhs != null) {
            if (!selfAssignment || rhs.equals(lhs)) {
              PointsToEdge shown = new PointsToEdge(fieldPointer, rhs, new InstanceFieldKey(fieldKey, field));
              PointsToEdge toShow1 = new PointsToEdge(rhsPointer, rhs);
              if (!toShow1.containsStringConst())
                toShowSet.add(toShow1);
              DependencyRule rule = new DependencyRule(shown, stmt, toShowSet, node, (SSACFG.BasicBlock) node.getIR()
                  .getBasicBlockForInstruction(instr));
              // Util.Debug("adding rule " + rule);
              addRule(rule, instr, node);
              rules.add(rule);
            }
          }
        }
      }
    }
    return rules;
  }

  private Set<DependencyRule> generateAbstractRulesForPutField(SSAInstruction instr, PointerKey lhsKey, PointerKey rhsKey,
      CGNode node, IField field, int lineId, int lineNum) {
    boolean selfAssignment = false;
    if (instr.getUse(0) == instr.getUse(1))
      selfAssignment = true; // special case: x.f = x

    // x.f = y
    TreeSet<DependencyRule> rules = new TreeSet<DependencyRule>();
    PointerVariable x = Util.makePointerVariable(lhsKey);
    PointerVariable y = Util.makePointerVariable(rhsKey);
    PointerStatement stmt = Util.makePointerStatement(instr, x, y, PointerStatement.EdgeType.PutField, field.toString(), lineId,
        lineNum);

    Set<InstanceKey> possibleXObjs = HashSetFactory.make(), possibleYVals = HashSetFactory.make();
    // consider possible values for x
    Iterator<Object> fieldValues = hg.getSuccNodes(lhsKey);
    while (fieldValues.hasNext()) {
      possibleXObjs.add((InstanceKey) fieldValues.next());
    }

    if (possibleXObjs.isEmpty())
      return rules;

    // consider possible values for y
    Iterator<Object> ptValues = hg.getSuccNodes(rhsKey);
    while (ptValues.hasNext()) {
      possibleYVals.add((InstanceKey) ptValues.next());
    }

    if (possibleYVals.isEmpty())
      return rules;

    PointerVariable xObj = SymbolicPointerVariable.makeSymbolicVar(possibleXObjs);
    PointerVariable yVal;
    if (!selfAssignment)
      yVal = SymbolicPointerVariable.makeSymbolicVar(possibleYVals);
    else
      yVal = xObj;

    PointsToEdge shown = new PointsToEdge(xObj, yVal, field);
    PointsToEdge toShow0 = PointsToEdge.make(x, xObj, null);
    PointsToEdge toShow1 = new PointsToEdge(y, yVal);
    TreeSet<PointsToEdge> toShowSet = new TreeSet<PointsToEdge>();
    toShowSet.add(toShow0);
    toShowSet.add(toShow1);
    DependencyRule rule = new DependencyRule(shown, stmt, toShowSet, node, (SSACFG.BasicBlock) node.getIR()
        .getBasicBlockForInstruction(instr));
    rules.add(rule);
    return rules;
  }

  private Set<DependencyRule> generateRulesForArrayStore(SSAInstruction instr, PointerKey lhsKey, PointerKey rhsKey, CGNode node,
      int lineId, int lineNum) {
    TreeSet<DependencyRule> rules = new TreeSet<DependencyRule>();
    PointerVariable lhs = Util.makePointerVariable(lhsKey);
    PointerVariable rhsPointer = Util.makePointerVariable(rhsKey);
    PointerStatement stmt = Util.makePointerStatement(instr, lhs, rhsPointer, PointerStatement.EdgeType.PutField,
        PointerStatement.ARRAY, lineId, lineNum);

    // consider possible values for x
    Iterator<Object> fieldValues = hg.getSuccNodes(lhsKey);
    while (fieldValues.hasNext()) {
      InstanceKey fieldKey = (InstanceKey) fieldValues.next();
      PointerVariable fieldPointer = Util.makePointerVariable(fieldKey);
      if (fieldPointer != null) {
        PointsToEdge toShow0 = PointsToEdge.make(lhs, fieldPointer, null);
        // consider possible values for y
        Iterator<Object> ptValues = hg.getSuccNodes(rhsKey);
        while (ptValues.hasNext()) {
          TreeSet<PointsToEdge> toShowSet = new TreeSet<PointsToEdge>();
          if (toShow0 != null && !toShow0.containsStringConst())
            toShowSet.add(toShow0);
          InstanceKey rhsInstance = (InstanceKey) ptValues.next();
          PointerVariable rhs = Util.makePointerVariable(rhsInstance);
          if (rhs != null) {
            PointsToEdge shown = new PointsToEdge(fieldPointer, rhs, new ArrayContentsKey(fieldKey));
            PointsToEdge toShow1 = new PointsToEdge(rhsPointer, rhs);
            if (!toShow1.containsStringConst())
              toShowSet.add(toShow1);
            DependencyRule rule = new DependencyRule(shown, stmt, toShowSet, node, (SSACFG.BasicBlock) node.getIR()
                .getBasicBlockForInstruction(instr));
            addRule(rule, instr, node);
            rules.add(rule);
          }
        }
      }
    }
    return rules;
  }

  private Set<DependencyRule> generateAbstractRulesForArrayStore(SSAArrayStoreInstruction instr, PointerKey lhsKey,
      PointerKey rhsKey, CGNode node, int lineId, int lineNum) {
    // x[contents] = y
    TreeSet<DependencyRule> rules = new TreeSet<DependencyRule>();
    PointerVariable lhs = Util.makePointerVariable(lhsKey);
    PointerVariable rhsPointer = Util.makePointerVariable(rhsKey);
    PointerStatement stmt = Util.makePointerStatement(instr, lhs, rhsPointer, PointerStatement.EdgeType.PutField,
        PointerStatement.ARRAY, lineId, lineNum);

    Set<InstanceKey> possibleXValues = HashSetFactory.make();//new HashSet<InstanceKey>();
    Set<InstanceKey> possibleYValues = HashSetFactory.make();//new HashSet<InstanceKey>();new HashSet<InstanceKey>();

    // consider possible values for x
    Iterator<Object> xValues = hg.getSuccNodes(lhsKey);
    while (xValues.hasNext()) {
      InstanceKey fieldKey = (InstanceKey) xValues.next();
      possibleXValues.add(fieldKey);
    }
    if (possibleXValues.isEmpty())
      return rules;
    // consider possible values for y
    Iterator<Object> ptValues = hg.getSuccNodes(rhsKey);
    while (ptValues.hasNext()) {
      InstanceKey rhsInstance = (InstanceKey) ptValues.next();
      possibleYValues.add(rhsInstance);
    }
    if (possibleYValues.isEmpty())
      return rules;
    PointerVariable xVal = SymbolicPointerVariable.makeSymbolicVar(possibleXValues);
    PointerVariable yVal = SymbolicPointerVariable.makeSymbolicVar(possibleYValues);

    PointsToEdge shown = new PointsToEdge(xVal, yVal, ARRAY_CONTENTS);
    TreeSet<PointsToEdge> toShowSet = new TreeSet<PointsToEdge>();
    PointsToEdge toShow0 = PointsToEdge.make(lhs, xVal, null);
    PointsToEdge toShow1 = new PointsToEdge(rhsPointer, yVal);
    toShowSet.add(toShow0);
    toShowSet.add(toShow1);
    DependencyRule rule = new DependencyRule(shown, stmt, toShowSet, node, (SSACFG.BasicBlock) node.getIR()
        .getBasicBlockForInstruction(instr));
    rules.add(rule);
    return rules;
  }

  // TEST
  /*
   * private void generateRulesForPrimitivePut(SSAInstruction instr, PointerKey
   * lhsKey, PointerKey rhsKey, CGNode node, String fieldName, int lineId, int
   * lineNum) { PointerVariable lhs = Util.makePointerVariable(lhsKey);
   * PointerVariable rhsPointer = Util.makePointerVariable(rhsKey);
   * PointerStatement stmt = Util.makePointerStatement(instr, lhs, rhsPointer,
   * PointerStatement.EdgeType.PutField, fieldName, lineId, lineNum);
   * 
   * // consider possible values for node.f Iterator fieldValues =
   * hg.getSuccNodes(lhsKey);
   * 
   * while (fieldValues.hasNext()) { PointerVariable fieldPointer =
   * Util.makePointerVariable(fieldValues.next()); //PointerVariable
   * fieldPointer = Util.makeSymbolicPointerVariable(fieldValues.next());
   * PointsToEdge toShow0 = new PointsToEdge(lhs, fieldPointer, null); //
   * consider possible values for rhs
   * 
   * Iterator ptValues = hg.getSuccNodes(rhsKey);
   * 
   * System.err.println(ptValues.hasNext()); //DependencyRule rule =
   * Util.makeUnconditionalDependencyRule(local, site,
   * PointerStatement.EdgeType.Assign, lineId, lineNum); while
   * (ptValues.hasNext()) { TreeSet<PointsToEdge> toShowSet = new
   * TreeSet<PointsToEdge>(); if (!toShow0.containsStringConst())
   * toShowSet.add(toShow0); PointerVariable rhs =
   * Util.makePointerVariable(ptValues.next()); PointsToEdge shown = new
   * PointsToEdge(fieldPointer, rhs, stmt.getFieldName()); PointsToEdge toShow1
   * = new PointsToEdge(rhsPointer, rhs, null); if
   * (!toShow1.containsStringConst()) toShowSet.add(toShow1); DependencyRule
   * rule = new DependencyRule(shown, stmt, toShowSet, node, (SSACFG.BasicBlock)
   * node.getIR().getBasicBlockForInstruction(instr));
   * //System.out.println("THE RULE: " + rule); addRule(rule, instr, node); } }
   * Util.Assert(false, "END TEST!"); System.exit(1); }
   */
  // end test

  public Map<Integer, DependencyRule> getRules() {
    return rules;
  }

  /*
   * public Map<Integer,Set<CGNode>> getLineMethodMap() { return lineMethodMap;
   * }
   * 
   * public Map<SSAInstruction,Integer> getInstrLineMap() { return instrLineMap;
   * }
   */

  /*
   * public Map<SSAInstruction,Set<DependencyRule>> getInstrModMap() { return
   * instrModMap; }
   */

  public CallGraph getCallGraph() {
    return cg;
  }

  public void addToLineMethodMap(int line, CGNode node) {
    Set<CGNode> methods = lineMethodMap.get(line);
    if (methods == null) {
      methods = HashSetFactory.make();//new HashSet<CGNode>();
      // System.err.println("linemethod adding " + node);
      methods.add(node);
      lineMethodMap.put(line, methods);
    } else {
      // System.err.println("linemethod adding " + node + "; size before was " +
      // methods.size());
      methods.add(node);
    }
    /*
     * for (CGNode nodez : methods) { System.err.println("have " + nodez); }
     */

  }

  public static String makeKeyForInstr(SSAInstruction instr, CGNode node) {
    StringBuilder builder = new StringBuilder();
    builder.append(instr.toString());
    builder.append(" & ");
    builder.append(node.toString());
    return builder.toString();
  }

  private void addRule(DependencyRule rule, SSAInstruction instr, CGNode node) {
    if (rule != null) {
      // if (DEBUG) System.out.println(rule);
      // System.out.println("THIS RULE: " + rule + " " + rule.hashCode());
      // System.out.println("contains? " + rules.contains(rule));
      // System.out.println(rules.add(rule));
      // rules.put(rule.hashCode(), rule);

      String instrKey = makeKeyForInstr(instr, node);
      TreeSet<DependencyRule> mods = instrModMap.get(instrKey);
      if (mods == null) {
        mods = new TreeSet<DependencyRule>();
        instrModMap.put(instrKey, mods);
      }
      mods.add(rule);
      TreeSet<DependencyRule> rules = nodeRuleMap.get(node);
      if (rules == null)
        rules = new TreeSet<DependencyRule>();
      rules.add(rule);
      // System.err.println("ADDING RULE " + rule + " for " + instr);
      nodeRuleMap.put(node, rules);
    }
  }

  public Set<DependencyRule> getRulesForInstr(SSAInstruction instr, CGNode node) {
    if (Options.GEN_DEPENDENCY_RULES_EAGERLY) {
      String instrKey = makeKeyForInstr(instr, node);
      Set<DependencyRule> rules = instrModMap.get(instrKey);
      return filterOutRefuted(rules);
    } else {
      if (Options.ABSTRACT_DEPENDENCY_RULES) {
        return generateAbstractRulesForInstr(instr, node, 0, 1, node.getIR());
      } else {
        Set<DependencyRule> rules = visit(instr, node, 0, 1, node.getIR());
        return rules;
      }
    }
  }

  private Set<DependencyRule> generateRulesForArrayLoad(SSAInstruction instr, CGNode node, int lineId, int lineNum) {
    Set<DependencyRule> rules = new TreeSet<DependencyRule>();
    SSAArrayLoadInstruction instruction = (SSAArrayLoadInstruction) instr;
    PointerKey def = hm.getPointerKeyForLocal(node, instruction.getDef());
    PointerKey refKey = hm.getPointerKeyForLocal(node, instruction.getArrayRef());
    if (def != null && refKey != null) {
      // this is a tricky case. refKey is a local var that points to a reference
      // pointing to a reference through a field = 3 levels of dereference
      PointerVariable lhs = Util.makePointerVariable(def);
      PointerVariable rhsPointerName = Util.makePointerVariable(refKey);
      String fieldName = PointerStatement.ARRAY;
      PointerStatement stmt = Util.makePointerStatement(instr, lhs, rhsPointerName, PointerStatement.EdgeType.GetField, fieldName,
          lineId, lineNum);
      // PointerStatement stmt = Util.makePointerStatement(lhs, rhsPointerName,
      // PointerStatement.ARRAY, fieldName, lineId, lineNum);
      // deref level 1 : what reference ref0 does the local var point to?
      Iterator<Object> ref0Values = hg.getSuccNodes(refKey);
      while (ref0Values.hasNext()) {
        InstanceKey ref0 = (InstanceKey) ref0Values.next();
        PointerVariable rhsPointer = Util.makePointerVariable(ref0);
        // deref level 2 : what reference ref1 does ref0 point to through its
        // array field?
        Iterator<Object> ref1Values = hg.getSuccNodes(ref0);
        while (ref1Values.hasNext()) {
          // deref level 3 : what reference ref2 does the ref1 point to?
          Object ref1 = ref1Values.next();
          Iterator<Object> ref2Values = hg.getSuccNodes(ref1);
          while (ref2Values.hasNext()) {
            // generate dependency rule
            PointerVariable rhs = Util.makePointerVariable(ref2Values.next());
            if (rhs != null) {
              PointsToEdge shown = new PointsToEdge(lhs, rhs);
              PointsToEdge toShow0 = new PointsToEdge(rhsPointerName, rhsPointer);
              PointsToEdge toShow1 = new PointsToEdge(rhsPointer, rhs, new ArrayContentsKey(ref0));

              TreeSet<PointsToEdge> toShowSet = new TreeSet<PointsToEdge>();
              if (!toShow0.containsStringConst())
                toShowSet.add(toShow0);
              if (!toShow1.containsStringConst())
                toShowSet.add(toShow1);
              DependencyRule rule = new DependencyRule(shown, stmt, toShowSet, node, (SSACFG.BasicBlock) node.getIR()
                  .getBasicBlockForInstruction(instr));
              addRule(rule, instr, node);
              rules.add(rule);
            }
          }
        }
      }
    }
    return rules;
  }

  private Set<DependencyRule> generateAbstractRulesForArrayLoad(SSAInstruction instr, CGNode node, int lineId, int lineNum) {
    // x = y[arr]
    Set<DependencyRule> rules = new TreeSet<DependencyRule>();
    SSAArrayLoadInstruction instruction = (SSAArrayLoadInstruction) instr;
    PointerKey def = hm.getPointerKeyForLocal(node, instruction.getDef());
    PointerKey refKey = hm.getPointerKeyForLocal(node, instruction.getArrayRef());
    if (def != null && refKey != null) {
      PointerVariable lhs = Util.makePointerVariable(def);
      PointerVariable rhsPointerName = Util.makePointerVariable(refKey);
      String fieldName = PointerStatement.ARRAY;
      PointerStatement stmt = Util.makePointerStatement(instr, lhs, rhsPointerName, PointerStatement.EdgeType.GetField, fieldName,
          lineId, lineNum);

      Set<InstanceKey> possibleYObjs = HashSetFactory.make(); //new HashSet<InstanceKey>();
      Set<InstanceKey> possibleArrValues = HashSetFactory.make(); //new HashSet<InstanceKey>();

      // TODO: possible loss of preicison here (merging contents of all arrays
      // that y can point to). consider addressing if it is a problem

      // deref level 1 : what reference ref0 does y point to?
      Iterator<Object> ref0Values = hg.getSuccNodes(refKey);
      while (ref0Values.hasNext()) {
        InstanceKey ref0 = (InstanceKey) ref0Values.next();
        possibleYObjs.add(ref0);
        Iterator<Object> ref1Values = hg.getSuccNodes(ref0);
        while (ref1Values.hasNext()) { // for each ArrayContentsKey of ref0
          Object ref1 = ref1Values.next();
          Iterator<Object> ref2Values = hg.getSuccNodes(ref1);
          while (ref2Values.hasNext()) { // for each possible value in the array
            // generate dependency rule
            possibleArrValues.add((InstanceKey) ref2Values.next());
          }
        }
      }
      if (possibleYObjs.isEmpty() || possibleArrValues.isEmpty())
        return rules;
      PointerVariable yObj = SymbolicPointerVariable.makeSymbolicVar(possibleYObjs);
      PointerVariable arrVal = SymbolicPointerVariable.makeSymbolicVar(possibleArrValues);

      PointsToEdge shown = new PointsToEdge(lhs, arrVal);
      PointsToEdge toShow0 = new PointsToEdge(rhsPointerName, yObj);
      PointsToEdge toShow1 = new PointsToEdge(yObj, arrVal, ARRAY_CONTENTS);

      TreeSet<PointsToEdge> toShowSet = new TreeSet<PointsToEdge>();
      toShowSet.add(toShow0);
      toShowSet.add(toShow1);
      DependencyRule rule = new DependencyRule(shown, stmt, toShowSet, node, (SSACFG.BasicBlock) node.getIR()
          .getBasicBlockForInstruction(instr));
      rules.add(rule);
    }
    return rules;
  }

  public int numRules() {
    return rules.size();
  }

  /*
   * public void handleProblemWithPointsToGraphCase(SSAInstruction instr, CGNode
   * node, IField f, int lineId, int lineNum) { SSAGetInstruction instruction =
   * (SSAGetInstruction) instr; PointerKey def =
   * heapModel.getPointerKeyForLocal(node, instruction.getDef()); PointerKey
   * refKey = heapModel.getPointerKeyForLocal(node, instruction.getRef()); //
   * this is a tricky case. refKey is a local var that points to a reference
   * pointing to a reference through a field = 3 levels of dereference
   * PointerVariable lhs = Util.makePointerVariable(def); PointerVariable
   * rhsPointerName = Util.makePointerVariable(refKey); String fieldName =
   * f.getDeclaringClass().toString() + "." + f.getName().toString();
   * //PointerStatement stmt = Util.makePointerStatement(lhs, rhsPointerName,
   * PointerStatement.EdgeType.GetField, f.getName().toString(), lineId,
   * lineNum); PointerStatement stmt = Util.makePointerStatement(instr, lhs,
   * rhsPointerName, PointerStatement.EdgeType.GetField, fieldName, lineId,
   * lineNum); Set<DependencyRule> mods = instrModMap.get(instr); if (mods ==
   * null) mods = new TreeSet<DependencyRule>(); Set<Object> seenRHSes = new
   * HashSet<Object>();
   * 
   * int ruleCounter = 0; // deref level 1 : what reference ref0 does the local
   * var point to? Iterator ref0Values = hg.getSuccNodes(refKey);
   * TreeSet<PointerVariable> middleVars = new TreeSet<PointerVariable>();
   * TreeSet<PointerVariable> rhsHeapLocs = new TreeSet<PointerVariable>();
   * 
   * while (ref0Values.hasNext()) { Object ref0 = ref0Values.next();
   * PointerVariable rhsPointer = Util.makePointerVariable(ref0);
   * middleVars.add(rhsPointer); // deref level 2 : what reference ref1 does
   * ref0 point to through its field? Iterator ref1Values =
   * hg.getSuccNodes(ref0); while (ref1Values.hasNext()) { Object ref1 =
   * ref1Values.next(); // deref level 3 : what reference ref2 does the ref1
   * point to? Iterator ref2Values = hg.getSuccNodes(ref1); while
   * (ref2Values.hasNext()) { Object rhsObj = ref2Values.next(); //if
   * (seenRHSes.contains(rhsObj)) continue; //else seenRHSes.add(rhsObj); //
   * generate dependency rule PointerVariable rhs =
   * Util.makePointerVariable(rhsObj); rhsHeapLocs.add(rhs); } } }
   * 
   * for (PointerVariable mid : middleVars) { for (PointerVariable rhs :
   * rhsHeapLocs) { PointsToEdge shown = new PointsToEdge(lhs, rhs, null);
   * PointsToEdge toShow0 = new PointsToEdge(rhsPointerName, mid, null);
   * //PointsToEdge toShow1 = new PointsToEdge(rhsPointer, rhs,
   * f.getName().toString()); PointsToEdge toShow1 = new PointsToEdge(mid, rhs,
   * f); TreeSet<PointsToEdge> toShowSet = new TreeSet<PointsToEdge>(); if
   * (!toShow0.containsStringConst()) toShowSet.add(toShow0); if
   * (!toShow1.containsStringConst()) toShowSet.add(toShow1); DependencyRule
   * rule = new DependencyRule(shown, stmt, toShowSet, node, (SSACFG.BasicBlock)
   * node.getIR().getBasicBlockForInstruction(instr)); addRule(rule, instr,
   * node); //rules.add(rule); mods.add(rule); } } }
   */

  public HeapModel getHeapModel() {
    return this.hm;
  }

  public HeapGraph getHeapGraph() {
    return this.hg;
  }

  public Map<CGNode, OrdinalSet<PointerKey>> getModRef() {
    return this.modRef;
  }

  public Map<PointerKey, Set<CGNode>> getReversedModRef() {
    if (reversedModRef == null) {
      Util.Print("computing reversed mod/ref");
      reversedModRef = HashMapFactory.make();//new HashMap<PointerKey, Set<CGNode>>();
      // create reverse mod/ref mapping: map from PointerKey's to CGNode's that
      // might modify them
      for (CGNode node : modRef.keySet()) { // for each CGNode
        for (PointerKey key : modRef.get(node)) { // get PointerKeys it modifies
          Set<CGNode> nodes = reversedModRef.get(key);
          if (nodes == null) {
            nodes = new HashSet<CGNode>();
            reversedModRef.put(key, nodes);
          }
          // if (Util.writesKeyLocally(node, key, heapModel, hg, cha)) {
          nodes.add(node);
          // }
        }
      }
    }
    return reversedModRef;
  }

  public ClassHierarchy getClassHierarchy() {
    return cha;
  }

  public AnalysisCache getCache() {
    return cache;
  }

  // dumb field needed because we can't get an IField for the "contents" field
  // of an array
  public static IField ARRAY_CONTENTS = new IField() {

    @Override
    public IClassHierarchy getClassHierarchy() {
      // TODO Auto-generated method stub
      return null;
    }

    @Override
    public Atom getName() {
      // TODO Auto-generated method stub
      return null;
    }

    @Override
    public IClass getDeclaringClass() {
      // TODO Auto-generated method stub
      return null;
    }

    @Override
    public boolean isVolatile() {
      // TODO Auto-generated method stub
      return false;
    }

    @Override
    public boolean isStatic() {
      // TODO Auto-generated method stub
      return false;
    }

    @Override
    public boolean isPublic() {
      // TODO Auto-generated method stub
      return false;
    }

    @Override
    public boolean isProtected() {
      // TODO Auto-generated method stub
      return false;
    }

    @Override
    public boolean isPrivate() {
      // TODO Auto-generated method stub
      return false;
    }

    @Override
    public boolean isFinal() {
      // TODO Auto-generated method stub
      return false;
    }

    @Override
    public FieldReference getReference() {
      // TODO Auto-generated method stub
      return null;
    }

    @Override
    public TypeReference getFieldTypeReference() {
      // TODO Auto-generated method stub
      return null;
    }

    @Override
    public Collection<Annotation> getAnnotations() {
      // TODO Auto-generated method stub
      return null;
    }
  };
  
}
